import 'dart:async';
import 'dart:typed_data';
import 'dart:ui' as ui;
import 'dart:math';
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:google_maps_flutter/google_maps_flutter.dart';
import 'package:geolocator/geolocator.dart';
import 'package:flutter/foundation.dart';
import 'dart:io';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:geocoding/geocoding.dart';
import 'package:smart_bus_mobility_platform1/models/bus_model.dart';
import 'package:smart_bus_mobility_platform1/resources/bus_service.dart';
import 'dart:convert';
import 'package:http/http.dart' as http;
import 'package:smart_bus_mobility_platform1/resources/map_service.dart' as som;
import 'package:smart_bus_mobility_platform1/utils/directions_repository.dart';
import 'package:smart_bus_mobility_platform1/utils/directions_model.dart';
import 'package:flutter_polyline_points/flutter_polyline_points.dart';
import 'package:smart_bus_mobility_platform1/widgets/map_zoom_controls.dart';
import 'package:smart_bus_mobility_platform1/utils/marker_icon_utils.dart';
import 'package:flutter/foundation.dart' show kIsWeb;

class DriverMapScreen extends StatefulWidget {
  const DriverMapScreen({super.key});

  @override
  State<DriverMapScreen> createState() => _DriverMapScreenState();
}

class _DriverMapScreenState extends State<DriverMapScreen> {
  final Completer<GoogleMapController> _controller = Completer();
  GoogleMapController? _mapController;
  static final CameraPosition _initialPosition = CameraPosition(
    target: LatLng(
      0.34540783865964797,
      32.54297125499706,
    ), // Kampala coordinates
    zoom: 14,
  );

  // Services
  final BusService _busService = BusService();

  // Driver data
  String? _driverId;
  String _driverName = 'Driver';
  String _driverEmail = '';
  BusModel? _driverBus;

  // Location tracking
  LatLng? _driverLocation;
  BitmapDescriptor? _driverMarkerIcon;
  BitmapDescriptor? _passengerMarkerIcon;
  final Map<String, BitmapDescriptor> _passengerIconCache = {};
  bool _isLoadingLocation = false;
  bool _isOnline = false;

  // Passengers data
  List<Map<String, dynamic>> _passengers = [];
  final Set<Marker> _allMarkers = {};
  Directions? _routeInfo;
  bool _isLoadingRoute = false;

  // UI state
  bool _isLoading = true;
  String _statusMessage = 'Loading...';

  // Route summary data
  double _totalRouteDistance = 0.0;
  List<som.BusStop> _optimizedRouteStops = [];
  bool _showRouteSummary = false;
  final Set<Polyline> _allPolylines = {}; // Add this for multiple polylines

  // Timer for passenger data refresh
  Timer? _passengerRefreshTimer;

  Future<void> _loadMarkerIcons() async {
    try {
      // Load driver marker icon (bus icon) - fixed size
      _driverMarkerIcon = await MarkerIcons.busIcon;

      // Load passenger marker icon - fixed size
      _passengerMarkerIcon = await MarkerIcons.passengerIcon;
    } catch (e) {
      print('Error loading marker icons: $e');
      // Fallback to default markers if custom icons fail
      _driverMarkerIcon = BitmapDescriptor.defaultMarkerWithHue(
        BitmapDescriptor.hueBlue,
      );
      _passengerMarkerIcon = BitmapDescriptor.defaultMarkerWithHue(
        BitmapDescriptor.hueRed,
      );
    }
  }

  // Get current user ID
  String? _getCurrentUserId() {
    final user = FirebaseAuth.instance.currentUser;
    return user?.uid;
  }

  // Load driver data and associated bus
  Future<void> _loadDriverData() async {
    try {
      final userId = _getCurrentUserId();
      if (userId == null) {
        setState(() {
          _statusMessage = 'User not authenticated';
          _isLoading = false;
        });
        return;
      }

      _driverId = userId;

      // Get driver user data
      final userDoc = await FirebaseFirestore.instance
          .collection('users')
          .doc(userId)
          .get();

      if (userDoc.exists) {
        final userData = userDoc.data() as Map<String, dynamic>;
        setState(() {
          _driverName = userData['name'] ?? userData['username'] ?? 'Driver';
          _driverEmail = userData['email'] ?? '';
        });
      }

      // Find the bus assigned to this driver
      final busSnapshot = await FirebaseFirestore.instance
          .collection('buses')
          .where('driverId', isEqualTo: _driverEmail)
          .where('isAvailable', isEqualTo: true)
          .limit(1)
          .get();

      if (busSnapshot.docs.isNotEmpty) {
        final busData = busSnapshot.docs.first.data();
        setState(() {
          _driverBus = BusModel.fromJson(busData, busSnapshot.docs.first.id);
        });

        // Load passengers for this bus
        await _loadPassengers();
      } else {
        print('No bus assigned to driver: $_driverEmail');
        setState(() {
          _statusMessage = 'No bus assigned to you';
          _isLoading = false;
        });
      }
    } catch (e) {
      print('Error loading driver data: $e');
      setState(() {
        _statusMessage = 'Error loading driver data: ${e.toString()}';
        _isLoading = false;
      });
    }
  }

  // Load passengers who have booked this driver's bus
  Future<void> _loadPassengers() async {
    if (_driverBus == null) {
      print('No driver bus available for loading passengers');
      setState(() {
        _isLoading = false;
      });
      return;
    }

    try {
      final bookingsSnapshot = await FirebaseFirestore.instance
          .collection('bookings')
          .where('busId', isEqualTo: _driverBus!.busId)
          .where('status', isEqualTo: 'confirmed')
          .get();

      final List<Map<String, dynamic>> passengers = [];

      for (var doc in bookingsSnapshot.docs) {
        final bookingData = doc.data();

        // Get user data for each booking
        final userDoc = await FirebaseFirestore.instance
            .collection('users')
            .doc(bookingData['userId'])
            .get();

        if (userDoc.exists) {
          final userData = userDoc.data() as Map<String, dynamic>;
          passengers.add({
            'bookingId': doc.id,
            'userId': bookingData['userId'],
            'userName': userData['name'] ?? userData['username'] ?? 'Passenger',
            'userEmail': userData['email'] ?? '',
            'pickupLocation': bookingData['pickupLocation'],
            'pickupAddress': bookingData['pickupAddress'] ?? 'Unknown location',
            'selectedSeats': bookingData['selectedSeats'] ?? [],
            'totalFare': bookingData['totalFare'] ?? 0.0,
            'departureDate': bookingData['departureDate'],
            'adultCount': bookingData['adultCount'] ?? 1,
            'childrenCount': bookingData['childrenCount'] ?? 0,
          });
        }
      }

      setState(() {
        _passengers = passengers;
        _isLoading = false;
      });

      _updateMarkers();
      await _drawOptimalRouteSOM();
    } catch (e) {
      print('Error loading passengers: $e');
      setState(() {
        _statusMessage = 'Error loading passengers: ${e.toString()}';
        _isLoading = false;
      });
    }
  }

  // Web-specific location permission check
  Future<bool> _checkWebLocationPermission() async {
    if (kIsWeb) {
      try {
        // For web, we'll try to get a position with a very short timeout
        // to check if permission is granted
        await Geolocator.getCurrentPosition(
          desiredAccuracy: LocationAccuracy.low,
          timeLimit: Duration(seconds: 3),
        );
        return true;
      } catch (e) {
        print('Web location permission check failed: $e');
        return false;
      }
    }
    return true;
  }

  // Get driver's current location
  Future<void> _getCurrentLocation() async {
    setState(() {
      _isLoadingLocation = true;
    });

    try {
      // Check if location services are enabled
      bool serviceEnabled = await Geolocator.isLocationServiceEnabled();
      if (!serviceEnabled) {
        print('Location services are disabled');
        _showSnackBar(
          'Location services are disabled. Please enable location services.',
        );
        // Use default location and continue
        _setDefaultLocation();
        return;
      }

      // Check location permissions
      LocationPermission permission = await Geolocator.checkPermission();
      if (permission == LocationPermission.denied) {
        permission = await Geolocator.requestPermission();
        if (permission == LocationPermission.denied) {
          print('Location permissions are denied');
          _showSnackBar('Location permissions are denied.');
          // Use default location and continue
          _setDefaultLocation();
          return;
        }
      }

      if (permission == LocationPermission.deniedForever) {
        print('Location permissions are permanently denied');
        _showSnackBar('Location permissions are permanently denied.');
        // Use default location and continue
        _setDefaultLocation();
        return;
      }

      // Additional web-specific permission check
      if (kIsWeb) {
        bool webPermissionGranted = await _checkWebLocationPermission();
        if (!webPermissionGranted) {
          _showSnackBar(
            'Please allow location access in your browser settings and try again.',
          );
          _setDefaultLocation();
          return;
        }
      }

      // Try to get current position with different strategies
      Position? position;

      try {
        // First try: High accuracy with timeout
        position = await Geolocator.getCurrentPosition(
          desiredAccuracy: LocationAccuracy.high,
          timeLimit: Duration(seconds: 10),
        );
      } catch (e) {
        print('High accuracy location failed, trying medium accuracy: $e');

        try {
          // Second try: Medium accuracy with longer timeout
          position = await Geolocator.getCurrentPosition(
            desiredAccuracy: LocationAccuracy.medium,
            timeLimit: Duration(seconds: 15),
          );
        } catch (e) {
          print('Medium accuracy location failed, trying low accuracy: $e');

          try {
            // Third try: Low accuracy with longest timeout
            position = await Geolocator.getCurrentPosition(
              desiredAccuracy: LocationAccuracy.low,
              timeLimit: Duration(seconds: 20),
            );
          } catch (e) {
            print('All location attempts failed: $e');

            // Fallback: Use last known position if available
            try {
              position = await Geolocator.getLastKnownPosition();
              if (position != null) {
                print('Using last known position as fallback');
              } else {
                throw Exception('No last known position available');
              }
            } catch (e) {
              print('Last known position also failed: $e');
              // Use default location as final fallback
              _setDefaultLocation();
              return;
            }
          }
        }
      }

      // Successfully got location
      setState(() {
        _driverLocation = LatLng(position!.latitude, position.longitude);
        _isLoadingLocation = false;
      });

      // Update camera to driver location
      if (_controller.isCompleted) {
        GoogleMapController controller = await _controller.future;
        controller.animateCamera(
          CameraUpdate.newCameraPosition(
            CameraPosition(target: _driverLocation!, zoom: 15),
          ),
        );
      }

      _updateMarkers();
      _updateDriverLocationInFirestore();
      await _drawOptimalRouteSOM();

      print(
        'Location updated successfully: ${position.latitude}, ${position.longitude}',
      );
    } catch (e) {
      print('Error getting location: $e');

      // Show appropriate error message
      String errorMessage = 'Error getting your location. ';
      if (e.toString().contains('Position update is unavailable')) {
        errorMessage +=
            'Please check your browser location settings and try again. For web browsers, make sure to allow location access when prompted.';
      } else if (e.toString().contains('timeout')) {
        errorMessage += 'Location request timed out. Please try again.';
      } else {
        errorMessage += 'Please try again.';
      }

      _showSnackBar(errorMessage);

      // Always set default location as fallback
      _setDefaultLocation();
    }
  }

  // Helper method to set default location
  void _setDefaultLocation() {
    setState(() {
      _driverLocation = LatLng(0.34540783865964797, 32.54297125499706);
      _isLoadingLocation = false;
    });

    // Update camera to default location
    if (_controller.isCompleted) {
      _controller.future.then((controller) {
        controller.animateCamera(
          CameraUpdate.newCameraPosition(
            CameraPosition(
              target: LatLng(0.34540783865964797, 32.54297125499706),
              zoom: 15,
            ),
          ),
        );
      });
    }

    _updateMarkers();
    _updateDriverLocationInFirestore();
    _drawOptimalRouteSOM();
  }

  // Test location method for debugging
  void _setTestLocation() {
    setState(() {
      _driverLocation = LatLng(0.3476, 32.5825); // Test coordinates in Kampala
      _isLoadingLocation = false;
    });

    // Update camera to test location
    if (_controller.isCompleted) {
      _controller.future.then((controller) {
        controller.animateCamera(
          CameraUpdate.newCameraPosition(
            CameraPosition(target: LatLng(0.3476, 32.5825), zoom: 15),
          ),
        );
      });
    }

    _updateMarkers();
    _updateDriverLocationInFirestore();
    _drawOptimalRouteSOM();

    _showSnackBar('Test location set successfully!');
  }

  // Update driver location in Firestore
  Future<void> _updateDriverLocationInFirestore() async {
    if (_driverLocation == null || _driverId == null) return;

    try {
      // Update driver location in users collection (where the driver document already exists)
      await FirebaseFirestore.instance
          .collection('users')
          .doc(_driverId)
          .update({
            'currentLocation': {
              'latitude': _driverLocation!.latitude,
              'longitude': _driverLocation!.longitude,
            },
            'isOnline': _isOnline,
            'lastUpdated': FieldValue.serverTimestamp(),
            'assignedBusId': _driverBus?.busId,
            'assignedBusPlate': _driverBus?.numberPlate,
          });

      print('Driver location updated successfully for driver: $_driverId');

      // Also update bus location if driver has an assigned bus
      if (_driverBus != null) {
        try {
          await _busService.updateBusLocation(
            _driverBus!.busId,
            _driverLocation!.latitude,
            _driverLocation!.longitude,
          );
          print(
            'Bus location updated successfully for bus: ${_driverBus!.busId}',
          );
        } catch (busError) {
          print('Error updating bus location: $busError');
        }
      }
    } catch (e) {
      print('Error updating driver location: $e');
      // If update fails, try to set the document with merge option
      try {
        await FirebaseFirestore.instance.collection('users').doc(_driverId).set(
          {
            'currentLocation': {
              'latitude': _driverLocation!.latitude,
              'longitude': _driverLocation!.longitude,
            },
            'isOnline': _isOnline,
            'lastUpdated': FieldValue.serverTimestamp(),
            'assignedBusId': _driverBus?.busId,
            'assignedBusPlate': _driverBus?.numberPlate,
          },
          SetOptions(merge: true),
        );
        print('Driver location set successfully with merge option');
      } catch (setError) {
        print('Error setting driver location: $setError');
      }
    }
  }

  // Ensure driver document exists in Firestore
  Future<void> _ensureDriverDocumentExists() async {
    if (_driverId == null) return;

    try {
      // Check if driver document exists in users collection
      final doc = await FirebaseFirestore.instance
          .collection('users')
          .doc(_driverId)
          .get();

      if (!doc.exists) {
        // Create the driver document in users collection
        await FirebaseFirestore.instance
            .collection('users')
            .doc(_driverId)
            .set({
              'driverId': _driverId,
              'driverName': _driverName,
              'driverEmail': _driverEmail,
              'isOnline': _isOnline,
              'createdAt': FieldValue.serverTimestamp(),
              'lastUpdated': FieldValue.serverTimestamp(),
            });
        print('Driver document created successfully');
      }
    } catch (e) {
      print('Error ensuring driver document exists: $e');
    }
  }

  // Update all markers on the map
  Future<void> _updateMarkers() async {
    _allMarkers.clear();

    // Add driver location marker
    if (_driverLocation != null && _driverMarkerIcon != null) {
      _allMarkers.add(
        Marker(
          markerId: MarkerId('driver_location'),
          position: _driverLocation!,
          icon: _driverMarkerIcon!,
          anchor: Offset(0.5, 0.5),
          flat: true,
          infoWindow: InfoWindow(
            title: 'Your Location (START)',
            snippet: 'Driver: $_driverName',
          ),
        ),
      );
    }

    // Add passenger markers with labeled icons
    for (int i = 0; i < _passengers.length; i++) {
      final passenger = _passengers[i];
      if (passenger['pickupLocation'] != null) {
        final location = passenger['pickupLocation'];
        final latLng = LatLng(location['latitude'], location['longitude']);
        final userName = passenger['userName'] ?? 'Passenger';
        final userId = passenger['userId'] ?? 'unknown';
        final label = userName.isNotEmpty ? userName[0].toUpperCase() : 'P';
        final icon = await _createLabeledPassengerIcon(label);
        _allMarkers.add(
          Marker(
            markerId: MarkerId('passenger_${passenger['userId']}'),
            position: latLng,
            icon: icon,
            anchor: Offset(0.5, 0.5),
            flat: true,
            infoWindow: InfoWindow(
              title: 'Passenger ${i + 1}: $userName',
              snippet:
                  '${passenger['selectedSeats'].length} seats • ${passenger['pickupAddress']}',
            ),
            onTap: () => _showPassengerDetails(passenger),
          ),
        );
      }
    }
    setState(() {});
  }

  // Helper to create a labeled marker icon for a passenger
  Future<BitmapDescriptor> _createLabeledPassengerIcon(String label) async {
    if (_passengerIconCache.containsKey(label)) {
      return _passengerIconCache[label]!;
    }

    // Set up canvas size
    const double width = 80;
    const double height = 90;

    final pictureRecorder = ui.PictureRecorder();
    final canvas = Canvas(pictureRecorder);

    // Draw white rounded rectangle for label background
    final labelRect = Rect.fromLTWH(0, 0, width, 36);
    final rrect = RRect.fromRectAndRadius(labelRect, Radius.circular(12));
    final paint = Paint()..color = Colors.white;
    canvas.drawRRect(rrect, paint);

    // Draw label text
    final textPainter = TextPainter(
      text: TextSpan(
        text: label,
        style: TextStyle(
          color: Colors.black,
          fontSize: 28,
          fontWeight: FontWeight.bold,
        ),
      ),
      textDirection: TextDirection.ltr,
    );
    textPainter.layout(minWidth: 0, maxWidth: width);
    final textOffset = Offset((width - textPainter.width) / 2, 4);
    textPainter.paint(canvas, textOffset);

    // Draw a simple circle as the marker below the label
    final markerCenter = Offset(width / 2, 68);
    final markerPaint = Paint()..color = Colors.deepPurple;
    canvas.drawCircle(markerCenter, 16, markerPaint);

    // Optionally, draw a white border
    final borderPaint = Paint()
      ..color = Colors.white
      ..style = PaintingStyle.stroke
      ..strokeWidth = 3;
    canvas.drawCircle(markerCenter, 16, borderPaint);

    // Convert to image and bytes
    final img = await pictureRecorder.endRecording().toImage(width.toInt(), height.toInt());
    final data = await img.toByteData(format: ui.ImageByteFormat.png);
    final bitmap = BitmapDescriptor.fromBytes(data!.buffer.asUint8List());
    _passengerIconCache[label] = bitmap;
    return bitmap;
  }

  // Update markers to show all passengers with labels
  Future<void> _updatePassengerMarkers() async {
    final Set<Marker> markers = {};
    // Add driver marker if location is available
    if (_driverLocation != null && _driverMarkerIcon != null) {
      markers.add(
        Marker(
          markerId: MarkerId('driver'),
          position: _driverLocation!,
          icon: _driverMarkerIcon!,
          infoWindow: InfoWindow(title: 'You (Driver)'),
        ),
      );
    }
    // Add passenger markers with labels
    for (final passenger in _passengers) {
      final LatLng? pickup = _getLatLngFromPickup(passenger['pickupLocation']);
      if (pickup != null) {
        final String name = passenger['userName'] ?? 'P';
        final BitmapDescriptor icon = await _createLabeledPassengerIcon(name[0].toUpperCase());
        markers.add(
          Marker(
            markerId: MarkerId('passenger_${passenger['userId']}'),
            position: pickup,
            icon: icon,
            infoWindow: InfoWindow(title: name),
          ),
        );
      }
    }
    setState(() {
      _allMarkers.clear();
      _allMarkers.addAll(markers);
    });
  }

  LatLng? _getLatLngFromPickup(dynamic pickup) {
    if (pickup == null) return null;
    if (pickup is Map && pickup['latitude'] != null && pickup['longitude'] != null) {
      return LatLng(pickup['latitude'], pickup['longitude']);
    }
    return null;
  }

  // Call _updatePassengerMarkers after loading passengers and driver location
  // For example, after _loadPassengers and after updating driver location

  // Show passenger details dialog
  void _showPassengerDetails(Map<String, dynamic> passenger) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: Text('Passenger Details'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text('Name: ${passenger['userName']}'),
            SizedBox(height: 8),
            Text('Email: ${passenger['userEmail']}'),
            SizedBox(height: 8),
            Text('Pickup: ${passenger['pickupAddress']}'),
            SizedBox(height: 8),
            Text('Seats: ${passenger['selectedSeats'].join(', ')}'),
            SizedBox(height: 8),
            Text(
              'Passengers: ${passenger['adultCount']} Adults, ${passenger['childrenCount']} Children',
            ),
            SizedBox(height: 8),
            Text(
              'Total Fare: UGX ${passenger['totalFare'].toStringAsFixed(0)}',
            ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: Text('Close'),
          ),
          ElevatedButton(
            onPressed: () {
              Navigator.pop(context);
              _navigateToPassenger(passenger);
            },
            style: ElevatedButton.styleFrom(
              backgroundColor: Colors.green,
              foregroundColor: Colors.white,
            ),
            child: Text('Navigate'),
          ),
        ],
      ),
    );
  }

  /// Fetches the route polyline from Google Directions API and updates _routeInfo
  Future<void> _fetchRoutePolyline(LatLng start, LatLng end) async {
    setState(() {
      _isLoadingRoute = true;
    });
    try {
      final directions = await DirectionsRepository().getDirections(
        origin: start,
        destination: end,
      );
      setState(() {
        _routeInfo = directions;
        _isLoadingRoute = false;
      });
    } catch (e) {
      print('Error fetching route polyline: $e');
      setState(() {
        _routeInfo = null;
        _isLoadingRoute = false;
      });
    }
  }

  // Add this function to draw all polylines automatically
  Future<void> _drawAllPassengerPolylines() async {
    if (_driverLocation == null) return;
    Set<Polyline> polylines = {};
    int polylineId = 0;
    for (final passenger in _passengers) {
      if (passenger['pickupLocation'] != null) {
        final location = passenger['pickupLocation'];
        final LatLng passengerLatLng = LatLng(
          location['latitude'],
          location['longitude'],
        );
        await _fetchRoutePolyline(_driverLocation!, passengerLatLng);
      }
    }
    setState(() {
      // _allPolylines.clear(); // This line is removed as per the edit hint
      // _allPolylines.addAll(polylines); // This line is removed as per the edit hint
    });
  }

  // Update _navigateToPassenger to draw the polyline
  void _navigateToPassenger(Map<String, dynamic> passenger) async {
    if (passenger['pickupLocation'] != null && _driverLocation != null) {
      final location = passenger['pickupLocation'];
      final LatLng passengerLatLng = LatLng(
        location['latitude'],
        location['longitude'],
      );

      // Move camera
      if (_controller.isCompleted) {
        _controller.future.then((controller) {
          controller.animateCamera(
            CameraUpdate.newCameraPosition(
              CameraPosition(target: passengerLatLng, zoom: 16),
            ),
          );
        });
      }

      _showSnackBar('Navigating to ${passenger['userName']}');
    }
  }

  // Toggle online status
  void _toggleOnlineStatus() {
    setState(() {
      _isOnline = !_isOnline;
    });
    _updateDriverLocationInFirestore();
    _showSnackBar(_isOnline ? 'You are now online' : 'You are now offline');
  }

  // Refresh data
  Future<void> _refreshData() async {
    setState(() {
      _isLoading = true;
      _statusMessage = 'Refreshing...';
    });

    try {
      await _loadDriverData();
      // Location updates are manual only - use the location refresh button

      setState(() {
        _isLoading = false;
        _statusMessage = 'Data refreshed (location manual)';
      });

      // Clear status message after a short delay
      Timer(Duration(seconds: 2), () {
        if (mounted) {
          setState(() {
            _statusMessage = '';
          });
        }
      });
    } catch (e) {
      print('Error during refresh: $e');
      setState(() {
        _isLoading = false;
        _statusMessage = 'Refresh failed: ${e.toString()}';
      });
    }
  }

  // Show snackbar message
  void _showSnackBar(String message) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(
        content: Text(message),
        duration: Duration(seconds: 2),
        behavior: SnackBarBehavior.floating,
      ),
    );
  }

  // Add this function to compute and draw the SOM optimal route
  Future<void> _drawOptimalRouteSOM() async {
    if (_driverLocation == null || _passengers.isEmpty) return;

    // Gather all stops: bus (driver) first, then all passengers
    List<som.BusStop> stops = [
      som.BusStop(
        id: 'bus',
        location: som.LatLng(
          _driverLocation!.latitude,
          _driverLocation!.longitude,
        ),
        name: 'Bus',
      ),
      ..._passengers.map(
        (p) => som.BusStop(
          id: p['userId'],
          location: som.LatLng(
            p['pickupLocation']['latitude'],
            p['pickupLocation']['longitude'],
          ),
          name: p['userName'],
        ),
      ),
    ];

    final somRoute = som.BusRouteSOM(
      coordinates: stops.map((s) => s.location).toList(),
    );
    final optimizedRoute = await somRoute.optimizeRoute(stops);

    // Convert som.LatLng to google_maps_flutter LatLng for map display
    final List<LatLng> routeCoords = optimizedRoute.routeCoordinates
        .map((c) => LatLng(c.latitude, c.longitude))
        .toList();

    // Calculate total distance
    double totalDistance = 0.0;
    for (int i = 0; i < routeCoords.length - 1; i++) {
      totalDistance += _calculateDistance(routeCoords[i], routeCoords[i + 1]);
    }

    // Update markers with route order labels
    _updateMarkersWithRouteOrder(optimizedRoute.orderedStops);

    // Create multiple polylines for better visualization
    _allPolylines.clear();

    // Draw initial bus route (from start to destination) if bus data is available
    if (_driverBus != null) {
      try {
        // Get the initial bus route coordinates
        final initialRoute = await _getInitialBusRoute();
        if (initialRoute.isNotEmpty) {
          _allPolylines.add(
            Polyline(
              polylineId: PolylineId('initial_bus_route'),
              points: initialRoute,
              color: Colors.blue,
              width: 4,
              geodesic: true,
            ),
          );
        }
      } catch (e) {
        print('Error drawing initial bus route: $e');
      }
    }

    // Main optimized route polyline (driver to passengers)
    _allPolylines.add(
      Polyline(
        polylineId: PolylineId('optimal_som_route'),
        points: routeCoords,
        color: Colors.deepPurple,
        width: 6,
        geodesic: true,
      ),
    );

    // Add segment polylines with different colors for each pickup
    final List<Color> segmentColors = [
      Colors.red,
      Colors.orange,
      Colors.yellow,
      Colors.green,
      Colors.blue,
      Colors.indigo,
      Colors.purple,
      Colors.pink,
      Colors.teal,
      Colors.cyan,
    ];

    for (int i = 0; i < routeCoords.length - 1; i++) {
      final colorIndex = i % segmentColors.length;
      _allPolylines.add(
        Polyline(
          polylineId: PolylineId('route_segment_$i'),
          points: [routeCoords[i], routeCoords[i + 1]],
          color: segmentColors[colorIndex],
          width: 4,
          geodesic: true,
        ),
      );
    }

    setState(() {
      // _allPolylines.clear(); // This line is removed as per the edit hint
      // _allPolylines.add(
      //   // This line is removed as per the edit hint
      //   Polyline(
      //     // This line is removed as per the edit hint
      //     polylineId: PolylineId(
      //       'optimal_som_route',
      //     ), // This line is removed as per the edit hint
      //     points: routeCoords, // This line is removed as per the edit hint
      //     color: Colors.deepPurple, // This line is removed as per the edit hint
      //     width: 5, // This line is removed as per the edit hint
      //   ), // This line is removed as per the edit hint
      // ); // This line is removed as per the edit hint
    });

    // Show route summary
    _displayRouteSummary(totalDistance, optimizedRoute.orderedStops);
  }

  // Get initial bus route coordinates (from start to destination)
  Future<List<LatLng>> _getInitialBusRoute() async {
    if (_driverBus == null) return [];

    try {
      // Get coordinates for start and destination points
      final startCoords = await _getCoordinatesForAddress(
        _driverBus!.startPoint,
      );
      final destCoords = await _getCoordinatesForAddress(
        _driverBus!.destination,
      );

      if (startCoords != null && destCoords != null) {
        // Get route between start and destination
        final directions = await DirectionsRepository().getDirections(
          origin: startCoords,
          destination: destCoords,
        );

        if (directions != null && directions.polylinePoints.isNotEmpty) {
          return directions.polylinePoints
              .map((point) => LatLng(point.latitude, point.longitude))
              .toList();
        }
      }

      // Fallback: return direct line between start and destination
      if (startCoords != null && destCoords != null) {
        return [startCoords, destCoords];
      }
    } catch (e) {
      print('Error getting initial bus route: $e');
    }

    return [];
  }

  // Helper method to get coordinates for an address
  Future<LatLng?> _getCoordinatesForAddress(String address) async {
    try {
      final locations = await locationFromAddress(address);
      if (locations.isNotEmpty) {
        return LatLng(locations.first.latitude, locations.first.longitude);
      }
    } catch (e) {
      print('Error getting coordinates for address $address: $e');
    }
    return null;
  }

  // Calculate distance between two points in kilometers
  double _calculateDistance(LatLng start, LatLng end) {
    const double earthRadius = 6371; // Earth's radius in kilometers
    final double lat1 = start.latitude * (pi / 180);
    final double lat2 = end.latitude * (pi / 180);
    final double deltaLat = (end.latitude - start.latitude) * (pi / 180);
    final double deltaLng = (end.longitude - start.longitude) * (pi / 180);

    final double a =
        sin(deltaLat / 2) * sin(deltaLat / 2) +
        cos(lat1) * cos(lat2) * sin(deltaLng / 2) * sin(deltaLng / 2);
    final double c = 2 * atan2(sqrt(a), sqrt(1 - a));

    return earthRadius * c;
  }

  // Update markers with route order labels
  void _updateMarkersWithRouteOrder(List<som.BusStop> routeStops) {
    _allMarkers.clear();

    // Add driver location marker
    if (_driverLocation != null && _driverMarkerIcon != null) {
      _allMarkers.add(
        Marker(
          markerId: MarkerId('driver_location'),
          position: _driverLocation!,
          icon: _driverMarkerIcon!,
          anchor: Offset(0.5, 0.5), // Center the marker
          flat: true, // Keep marker flat (not tilted)
          infoWindow: InfoWindow(
            title: 'Your Location (START)',
            snippet: 'Driver: $_driverName',
          ),
        ),
      );
    }

    // Add passenger markers with route order
    for (int i = 0; i < routeStops.length; i++) {
      final stop = routeStops[i];
      if (stop.id != 'bus') {
        // Find the passenger data
        final passenger = _passengers.firstWhere(
          (p) => p['userId'] == stop.id,
          orElse: () => <String, dynamic>{},
        );

        if (passenger.isNotEmpty &&
            passenger['pickupLocation'] != null &&
            _passengerMarkerIcon != null) {
          final location = passenger['pickupLocation'];
          final latLng = LatLng(location['latitude'], location['longitude']);

          _allMarkers.add(
            Marker(
              markerId: MarkerId('passenger_${passenger['userId']}'),
              position: latLng,
              icon: _passengerMarkerIcon!,
              anchor: Offset(0.5, 0.5), // Center the marker
              flat: true, // Keep marker flat (not tilted)
              infoWindow: InfoWindow(
                title: 'Stop $i: ${passenger['userName']}',
                snippet:
                    '${passenger['selectedSeats'].length} seats • ${passenger['pickupAddress']}',
              ),
              onTap: () => _showPassengerDetails(passenger),
            ),
          );
        }
      }
    }
  }

  // Show route summary in a card on screen
  void _displayRouteSummary(
    double totalDistance,
    List<som.BusStop> routeStops,
  ) {
    setState(() {
      _totalRouteDistance = totalDistance;
      _optimizedRouteStops = routeStops;
      _showRouteSummary = true;
    });
  }

  @override
  void initState() {
    super.initState();

    // Add a timeout to prevent infinite loading
    Timer(Duration(seconds: 30), () {
      if (mounted && _isLoading) {
        print('Loading timeout reached, forcing completion');
        setState(() {
          _isLoading = false;
          _statusMessage = 'Loading completed with timeout';
        });
      }
    });

    _loadMarkerIcons();
    _loadDriverData();
    // Location is now manual only - use the location refresh button or manual input

    // Set up periodic refresh for passengers
    _passengerRefreshTimer = Timer.periodic(Duration(minutes: 2), (timer) {
      if (mounted) {
        _loadPassengers();
      }
    });

    // Location updates are now manual only - no automatic polling
    // Users can use the location refresh button or manual location input
  }

  @override
  void dispose() {
    // Cancel passenger refresh timer
    _passengerRefreshTimer?.cancel();

    // Dispose map controller properly
    _mapController?.dispose();

    // Clear any pending operations
    if (_controller.isCompleted) {
      _controller.future.then((controller) {
        try {
          controller.dispose();
        } catch (e) {
          print('Error disposing map controller: $e');
        }
      });
    }

    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      backgroundColor: const Color(0xFFF8F9FA),
      appBar: AppBar(
        title: Text(
          'Driver Map',
          style: TextStyle(fontWeight: FontWeight.bold, color: Colors.white),
        ),
        backgroundColor: const Color(0xFF576238),
        foregroundColor: Colors.white,
        elevation: 0,
        actions: [
          IconButton(
            icon: Icon(
              _isOnline
                  ? Icons.radio_button_checked
                  : Icons.radio_button_unchecked,
            ),
            onPressed: _toggleOnlineStatus,
            tooltip: _isOnline ? 'Go Offline' : 'Go Online',
          ),
          IconButton(
            icon: Icon(Icons.refresh),
            onPressed: _refreshData,
            tooltip: 'Refresh',
          ),
          IconButton(
            icon: Icon(
              _showRouteSummary ? Icons.visibility_off : Icons.visibility,
            ),
            onPressed: () {
              setState(() {
                _showRouteSummary = !_showRouteSummary;
              });
            },
            tooltip: _showRouteSummary ? 'Hide Route' : 'Show Route',
          ),
        ],
      ),
      body: _isLoading
          ? Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  CircularProgressIndicator(color: const Color(0xFF576238)),
                  SizedBox(height: 16),
                  Text(
                    _statusMessage,
                    style: TextStyle(fontSize: 16, color: Colors.grey[600]),
                  ),
                ],
              ),
            )
          : Column(
              children: [
                // Driver Status Card
                Container(
                  margin: EdgeInsets.all(16),
                  padding: EdgeInsets.all(16),
                  decoration: BoxDecoration(
                    color: Colors.white,
                    borderRadius: BorderRadius.circular(12),
                    boxShadow: [
                      BoxShadow(
                        color: Colors.black.withValues(alpha: 0.1),
                        blurRadius: 8,
                        offset: Offset(0, 4),
                      ),
                    ],
                  ),
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Row(
                        children: [
                          Container(
                            padding: EdgeInsets.all(8),
                            decoration: BoxDecoration(
                              color: const Color(0xFF576238),
                              borderRadius: BorderRadius.circular(8),
                            ),
                            child: Icon(
                              Icons.directions_bus,
                              color: Colors.white,
                              size: 24,
                            ),
                          ),
                          SizedBox(width: 12),
                          Expanded(
                            child: Column(
                              crossAxisAlignment: CrossAxisAlignment.start,
                              children: [
                                Text(
                                  'Driver Dashboard',
                                  style: TextStyle(
                                    fontSize: 16,
                                    fontWeight: FontWeight.bold,
                                    color: Color(0xFF111827),
                                  ),
                                ),
                                Text(
                                  _driverBus?.numberPlate ?? 'No bus assigned',
                                  style: TextStyle(
                                    fontSize: 14,
                                    color: Color(0xFF6B7280),
                                  ),
                                ),
                              ],
                            ),
                          ),
                          Container(
                            padding: EdgeInsets.symmetric(
                              horizontal: 12,
                              vertical: 6,
                            ),
                            decoration: BoxDecoration(
                              color: _isOnline ? Colors.green : Colors.grey,
                              borderRadius: BorderRadius.circular(16),
                            ),
                            child: Text(
                              _isOnline ? 'Online' : 'Offline',
                              style: TextStyle(
                                color: Colors.white,
                                fontSize: 12,
                                fontWeight: FontWeight.bold,
                              ),
                            ),
                          ),
                        ],
                      ),
                      if (_driverBus != null) ...[
                        SizedBox(height: 12),
                        Row(
                          children: [
                            Icon(
                              Icons.route,
                              size: 16,
                              color: Color(0xFF6B7280),
                            ),
                            SizedBox(width: 8),
                            Expanded(
                              child: Text(
                                '${_driverBus!.startPoint} → ${_driverBus!.destination}',
                                style: TextStyle(
                                  fontSize: 14,
                                  color: Color(0xFF6B7280),
                                ),
                              ),
                            ),
                          ],
                        ),
                        SizedBox(height: 8),
                        Row(
                          children: [
                            Icon(
                              Icons.people,
                              size: 16,
                              color: Color(0xFF6B7280),
                            ),
                            SizedBox(width: 8),
                            Text(
                              '${_passengers.length} passengers',
                              style: TextStyle(
                                fontSize: 14,
                                color: Color(0xFF6B7280),
                              ),
                            ),
                          ],
                        ),
                      ],
                    ],
                  ),
                ),

                // Map
                Expanded(
                  child: Container(
                    margin: EdgeInsets.symmetric(horizontal: 16),
                    decoration: BoxDecoration(
                      borderRadius: BorderRadius.circular(12),
                      boxShadow: [
                        BoxShadow(
                          color: Colors.black.withOpacity(0.1),
                          blurRadius: 8,
                          offset: Offset(0, 4),
                        ),
                      ],
                    ),
                    child: ClipRRect(
                      borderRadius: BorderRadius.circular(12),
                      child: Stack(
                        children: [
                          GoogleMap(
                            onMapCreated: (GoogleMapController controller) {
                              _controller.complete(controller);
                              _mapController = controller;
                            },
                            initialCameraPosition: _initialPosition,
                            markers: _allMarkers,
                            polylines: _allPolylines,
                            myLocationEnabled: true,
                            myLocationButtonEnabled: false,
                            zoomControlsEnabled: false,
                            mapToolbarEnabled: false,
                            onTap: (LatLng location) {
                              // Handle map tap if needed
                            },
                          ),
                          if (_isLoadingRoute)
                            const Center(child: CircularProgressIndicator()),

                          // Zoom controls
                          MapZoomControls(mapController: _mapController),

                          // Google Maps style circular buttons (stacked vertically on bottom right)
                          Positioned(
                            bottom: 16,
                            right: 16,
                            child: Column(
                              children: [
                                // My Location button
                                Container(
                                  decoration: BoxDecoration(
                                    color: Colors.white,
                                    shape: BoxShape.circle,
                                    boxShadow: [
                                      BoxShadow(
                                        color: Colors.black.withValues(alpha: 0.2),
                                        blurRadius: 8,
                                        offset: Offset(0, 2),
                                      ),
                                    ],
                                  ),
                                  child: IconButton(
                                    onPressed: _isLoadingLocation
                                        ? null
                                        : _getCurrentLocation,
                                    icon: _isLoadingLocation
                                        ? SizedBox(
                                            width: 20,
                                            height: 20,
                                            child: CircularProgressIndicator(
                                              strokeWidth: 2,
                                              valueColor:
                                                  AlwaysStoppedAnimation<Color>(
                                                    Colors.grey,
                                                  ),
                                            ),
                                          )
                                        : Icon(
                                            Icons.my_location,
                                            color: Colors.grey[700],
                                          ),
                                    tooltip: 'My Location',
                                    style: IconButton.styleFrom(
                                      backgroundColor: Colors.white,
                                      padding: EdgeInsets.all(12),
                                    ),
                                  ),
                                ),
                                SizedBox(height: 12),
                                // Refresh button
                                Container(
                                  decoration: BoxDecoration(
                                    color: Colors.blue,
                                    shape: BoxShape.circle,
                                    boxShadow: [
                                      BoxShadow(
                                        color: Colors.black.withValues(alpha: 0.2),
                                        blurRadius: 8,
                                        offset: Offset(0, 2),
                                      ),
                                    ],
                                  ),
                                  child: IconButton(
                                    onPressed: _refreshData,
                                    icon: Icon(
                                      Icons.refresh,
                                      color: Colors.white,
                                    ),
                                    tooltip: 'Refresh Data',
                                    style: IconButton.styleFrom(
                                      backgroundColor: Colors.blue,
                                      padding: EdgeInsets.all(12),
                                    ),
                                  ),
                                ),
                              ],
                            ),
                          ),
                        ],
                      ),
                    ),
                  ),
                ),
              ],
            ),
                ),
              ],
            ),
          ),
        ),
      );
    }
}


